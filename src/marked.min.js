// Enhanced markdown parser with custom renderer support
window.marked = {
    Renderer: function() {
        this.code = function(code, lang) {
            return `<pre><code class="language-${lang || 'plaintext'}">${code}</code></pre>`;
        };
        
        this.codespan = function(code) {
            return `<code class="inline-code">${code}</code>`;
        };

        this.math = function(math, display) {
            try {
                // Check if KaTeX is available
                if (typeof katex !== 'undefined') {
                    const result = katex.renderToString(math, {
                        displayMode: display,
                        throwOnError: false,
                        errorColor: '#cc0000',
                        macros: {
                            "\\RR": "\\mathbb{R}",
                            "\\NN": "\\mathbb{N}",
                            "\\ZZ": "\\mathbb{Z}",
                            "\\QQ": "\\mathbb{Q}",
                            "\\CC": "\\mathbb{C}"
                        }
                    });
                    
                    // Check if the result contains error indicators
                    if (result.includes('katex-error') || result.includes('ParseError')) {
                        console.warn('KaTeX parsing error for:', math);
                        return `<span class="math-error">${math}</span>`;
                    }
                    
                    return result;
                } else {
                    console.warn('KaTeX not available, showing plain text');
                    return `<span class="math-plain">${math}</span>`;
                }
            } catch (e) {
                console.error('KaTeX rendering error:', e);
                return `<span class="math-error">${math}</span>`;
            }
        };
        
        return this;
    },
    
    setOptions: function(options) {
        this.options = options || {};
        this.customRenderer = options.renderer;
        return this;
    },
    
    options: {},
    customRenderer: null,
    
    parse: function(markdown) {
        if (!markdown) return '';
        
        let html = markdown;
        
        // Create a custom renderer instance
        const renderer = new this.Renderer();
        
        // Handle block math equations ($$...$$) - must be processed before other markdown
        html = html.replace(/\$\$([\s\S]*?)\$\$/g, (match, math) => {
            return renderer.math(math.trim(), true);
        });
        
        // Handle inline math equations ($...$) - must be processed before other markdown
        html = html.replace(/\$([^\$\n]+?)\$/g, (match, math) => {
            // Skip if it's part of a code block
            if (match.includes('```')) return match;
            return renderer.math(math.trim(), false);
        });
        
        // Use custom renderer for code blocks if available
        if (this.customRenderer && this.customRenderer.code) {
            // Extract code blocks with language detection
            html = html.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, lang, code) => {
                return this.customRenderer.code(code.trim(), lang || 'plaintext');
            });
        } else {
            // Default code block handling
            html = html.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, lang, code) => {
                return `<pre><code class="language-${lang || 'plaintext'}">${code.trim()}</code></pre>`;
            });
        }
        
        // Use custom renderer for inline code if available
        if (this.customRenderer && this.customRenderer.codespan) {
            html = html.replace(/`([^`]+)`/g, (match, code) => {
                return this.customRenderer.codespan(code);
            });
        } else {
            // Default inline code handling
            html = html.replace(/`([^`]+)`/g, '<code class="inline-code">$1</code>');
        }
        
        // Continue with other markdown parsing
        html = html
            // Headers
            .replace(/^### (.*$)/gim, '<h3>$1</h3>')
            .replace(/^## (.*$)/gim, '<h2>$1</h2>')
            .replace(/^# (.*$)/gim, '<h1>$1</h1>')
            
            // Bold
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/__(.*?)__/g, '<strong>$1</strong>')
            
            // Italic
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            .replace(/_(.*?)_/g, '<em>$1</em>')
            
            // Strikethrough
            .replace(/~~(.*?)~~/g, '<del>$1</del>')
            
            // Checkboxes (for planning steps)
            .replace(/^\s*- \[x\] (.*)$/gim, '<div class="checkbox checked"><input type="checkbox" checked disabled> <del>$1</del></div>')
            .replace(/^\s*- \[ \] (.*)$/gim, '<div class="checkbox"><input type="checkbox" disabled> $1</div>')
            
            // Numbered lists (for planning steps)
            .replace(/^\s*(\d+)\. (.*)$/gim, '<div class="numbered-step"><span class="step-number">$1.</span> $2</div>')
            
            // Links
            .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>')
            
            // Line breaks
            .replace(/\n\n/g, '</p><p>')
            .replace(/\n/g, '<br>');
        
        // Wrap in paragraph tags if not already wrapped
        if (!html.startsWith('<')) {
            html = '<p>' + html + '</p>';
        }
        
        // Clean up empty paragraphs
        html = html.replace(/<p><\/p>/g, '');
        
        return html;
    }
};
