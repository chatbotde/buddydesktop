// Enhanced markdown parser with streaming support and custom renderer
window.marked = {
    Renderer: function() {
        this.code = function(code, lang) {
            return `<pre><code class="language-${lang || 'plaintext'}">${code}</code></pre>`;
        };
        
        this.codespan = function(code) {
            return `<code class="inline-code">${code}</code>`;
        };

        // Math processing DISABLED - handled by mathBlockProcessor to prevent duplicates
        this.math = function(math, display) {
            console.log('üìù marked.min.js: Math processing skipped to prevent duplicates');
            // Return the math as-is, let mathBlockProcessor handle it
            return display ? `$$${math}$$` : `$${math}$`;
        };
        
        return this;
    },

    // Enhanced streaming support
    StreamingRenderer: function() {
        const baseRenderer = new this.Renderer();
        
        // Add streaming-aware methods
        this.code = function(code, lang) {
            return `<pre class="streaming-code"><code class="language-${lang || 'plaintext'} streaming-element">${code}</code></pre>`;
        };
        
        this.codespan = function(code) {
            return `<code class="inline-code streaming-element">${code}</code>`;
        };
        
        this.heading = function(text, level) {
            return `<h${level} class="streaming-header streaming-element">${text}</h${level}>`;
        };
        
        this.paragraph = function(text) {
            return `<p class="streaming-paragraph streaming-element">${text}</p>`;
        };
        
        this.blockquote = function(quote) {
            return `<blockquote class="streaming-blockquote streaming-element">${quote}</blockquote>`;
        };
        
        this.list = function(body, ordered) {
            const tag = ordered ? 'ol' : 'ul';
            return `<${tag} class="streaming-list streaming-element">${body}</${tag}>`;
        };
        
        this.listitem = function(text) {
            return `<li class="streaming-list-item streaming-element">${text}</li>`;
        };
        
        // Copy other methods from base renderer
        Object.setPrototypeOf(this, baseRenderer);
        
        return this;
    },
    
    setOptions: function(options) {
        this.options = options || {};
        this.customRenderer = options.renderer;
        this.streamingMode = options.streamingMode || false;
        return this;
    },
    
    options: {},
    customRenderer: null,
    streamingMode: false,
    
    // Enhanced parse method with streaming support
    parse: function(markdown, options = {}) {
        if (!markdown) return '';
        
        const useStreaming = options.streamingMode || this.streamingMode;
        let html = markdown;
        
        // Create appropriate renderer
        const renderer = useStreaming ? new this.StreamingRenderer() : new this.Renderer();
        
        // Math processing DISABLED to prevent duplicate rendering
        console.log('üìù marked.min.js: Math processing disabled to prevent duplicates');
        
        // Use custom renderer for code blocks if available
        if (this.customRenderer && this.customRenderer.code) {
            html = html.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, lang, code) => {
                return this.customRenderer.code(code.trim(), lang || 'plaintext');
            });
        } else {
            // Enhanced code block handling with streaming support
            html = html.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, lang, code) => {
                const streamingClass = useStreaming ? ' streaming-element' : '';
                return `<pre class="language-${lang || 'plaintext'}${streamingClass}"><code class="hljs${streamingClass}">${code.trim()}</code></pre>`;
            });
        }
        
        // Enhanced inline code handling
        if (this.customRenderer && this.customRenderer.codespan) {
            html = html.replace(/`([^`]+)`/g, (match, code) => {
                return this.customRenderer.codespan(code);
            });
        } else {
            const streamingClass = useStreaming ? ' streaming-element' : '';
            html = html.replace(/`([^`]+)`/g, `<code class="inline-code${streamingClass}">$1</code>`);
        }
        
        // Enhanced markdown processing with streaming classes
        const streamingSuffix = useStreaming ? ' streaming-element' : '';
        
        html = html
            // Headers with streaming support
            .replace(/^### (.*$)/gim, `<h3 class="md-h3${streamingSuffix}">$1</h3>`)
            .replace(/^## (.*$)/gim, `<h2 class="md-h2${streamingSuffix}">$1</h2>`)
            .replace(/^# (.*$)/gim, `<h1 class="md-h1${streamingSuffix}">$1</h1>`)
            
            // Enhanced text formatting
            .replace(/\*\*(.*?)\*\*/g, `<strong class="md-bold${streamingSuffix}">$1</strong>`)
            .replace(/__(.*?)__/g, `<strong class="md-bold${streamingSuffix}">$1</strong>`)
            .replace(/\*(.*?)\*/g, `<em class="md-italic${streamingSuffix}">$1</em>`)
            .replace(/_(.*?)_/g, `<em class="md-italic${streamingSuffix}">$1</em>`)
            .replace(/~~(.*?)~~/g, `<del class="md-strikethrough${streamingSuffix}">$1</del>`)
            
            // Enhanced lists with streaming support
            .replace(/^\s*- \[x\] (.*)$/gim, `<div class="checkbox checked${streamingSuffix}"><input type="checkbox" checked disabled> <del>$1</del></div>`)
            .replace(/^\s*- \[ \] (.*)$/gim, `<div class="checkbox${streamingSuffix}"><input type="checkbox" disabled> $1</div>`)
            .replace(/^\s*(\d+)\. (.*)$/gim, `<div class="numbered-step${streamingSuffix}"><span class="step-number">$1.</span> $2</div>`)
            
            // Enhanced links
            .replace(/\[([^\]]+)\]\(([^)]+)\)/g, `<a href="$2" class="md-link${streamingSuffix}" target="_blank">$1</a>`)
            
            // Line breaks and paragraphs
            .replace(/\n\n/g, '</p><p>')
            .replace(/\n/g, '<br>');
        
        // Wrap in paragraph tags if not already wrapped
        if (!html.startsWith('<')) {
            const paragraphClass = useStreaming ? ' class="streaming-element"' : '';
            html = `<p${paragraphClass}>` + html + '</p>';
        }
        
        // Clean up empty paragraphs
        html = html.replace(/<p[^>]*><\/p>/g, '');
        
        return html;
    },

    // Progressive parsing for streaming
    parseProgressive: function(markdown, currentIndex = 0, options = {}) {
        const chunk = markdown.slice(0, currentIndex);
        const result = this.parse(chunk, { ...options, streamingMode: true });
        
        return {
            html: result,
            isComplete: currentIndex >= markdown.length,
            progress: currentIndex / markdown.length,
            nextIndex: Math.min(currentIndex + (options.chunkSize || 10), markdown.length)
        };
    },

    // Streaming CSS
    getStreamingCSS: function() {
        return `
            .streaming-element {
                animation: streamingFadeIn 0.3s ease-in forwards;
            }
            
            .streaming-element.forming {
                background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.1), transparent);
                background-size: 200% 100%;
                animation: streamingShimmer 1.5s infinite, streamingFadeIn 0.3s ease-in forwards;
            }
            
            .streaming-element.complete {
                animation: streamingComplete 0.4s ease-out;
            }
            
            @keyframes streamingFadeIn {
                from { opacity: 0; transform: translateY(-2px); }
                to { opacity: 1; transform: translateY(0); }
            }
            
            @keyframes streamingShimmer {
                0% { background-position: -200% 0; }
                100% { background-position: 200% 0; }
            }
            
            @keyframes streamingComplete {
                0% { 
                    background-color: rgba(59, 130, 246, 0.2);
                    transform: scale(1.01);
                }
                100% { 
                    background-color: transparent;
                    transform: scale(1);
                }
            }
            
            .md-bold.streaming-element { color: var(--md-bold-color, inherit); font-weight: 600; }
            .md-italic.streaming-element { color: var(--md-italic-color, inherit); font-style: italic; }
            .md-link.streaming-element { color: var(--md-link-color, #3b82f6); text-decoration: none; }
            .md-h1.streaming-element { font-size: 2rem; font-weight: 700; margin: 1rem 0 0.5rem 0; }
            .md-h2.streaming-element { font-size: 1.5rem; font-weight: 700; margin: 1rem 0 0.5rem 0; }
            .md-h3.streaming-element { font-size: 1.25rem; font-weight: 700; margin: 1rem 0 0.5rem 0; }
        `;
    }
};
